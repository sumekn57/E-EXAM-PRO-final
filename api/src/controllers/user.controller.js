import { HttpStatus, roleEnum } from '../constant/constant.js';
import sendSuccessResponse from '../helper/apiResponseHandler.js';
import { User } from '../schemaModels/model.js';
import asyncErrorHandler from '../utils/asyncHandler.js';
import { throwError } from '../utils/throwError.js';
import generateStrongPassword from '../utils/passwordGenerator.js';
import sendMail from '../utils/sendMail.js';

import bcrypt from "bcrypt";

export const createUser = asyncErrorHandler(async (req, res) => {

    const { name, email, role, phoneNumber, address } = req.body;

    /* Checking if all the fields are attached to the req body  */
    if (!name || !email || !role) {
        throwError({ statusCode: HttpStatus.BAD_REQUEST, message: "All the fields are required", })
    }

    // checking the value of role is valid or not
    if (!roleEnum.includes(role)) {
        throwError({ statusCode: HttpStatus.BAD_REQUEST, message: "Invalid roles", })
    }

    // Getting user data if it exists
    const isUserExists = await User.findOne({ email });

    if (isUserExists) {
        throwError({ statusCode: HttpStatus.CONFLICT, message: "User already exists" })
    }

    // Generating the 8 digit strong password
    const autoGeneratedPassword = generateStrongPassword()

    const mailMessage = {
        from: process.env.email,
        to: email,
        subject: 'Welcome to Our Online Exam System!',
        html: `
          <p>Hello ${name},</p>
          <p>Welcome to the system! Your account has been created.</p>
          <p>Your autogenerated password is: <b>${autoGeneratedPassword}<b> </p>
          <p>Please make sure to change your password after logging in for the first time.</p>
          <p>Thank you!</p>
        `,
    };

    // Storing user data in db
    const user = User({ name, email, role, password: autoGeneratedPassword, phoneNumber, address })
    await user.save();

    // Sending the mail 
    await sendMail(mailMessage)

    sendSuccessResponse({
        res,
        statusCode: HttpStatus.CREATED,
        message: "User is created successfully"
    })

})

// Get all Users
export const getAllUsers = asyncErrorHandler(async (req, res) => {

    const users = await User.find({}, { password: false }).sort({ createdAt: -1 });

    sendSuccessResponse({
        res,
        statusCode: HttpStatus.OK,
        message: "All users data has been retrieved",
        data: users
    })


})


export const userLogin = asyncErrorHandler(async (req, res) => {

    const { email, password } = req.body

    if (!email || !password) {
        throwError({ message: "All the fields are required", statusCode: HttpStatus.BAD_REQUEST })
    }

    // checking is user exists or not
    const user = await User.findOne({ email });

    if (!user) {
        throwError({ message: "User not found", statusCode: HttpStatus.NOT_FOUND })
    }

    // Comparing the password
    const isPasswordValid = await bcrypt.compare(password, user.password)

    if (!isPasswordValid) {
        throwError({ message: "Wrong password, please check your password", statusCode: HttpStatus.UNAUTHORIZED })
    }

    // Cannot send password to frontend because of security issues
    user.password = null;

    // return res.status(HttpStatus.OK).json({ message: `Authentication successful, Welcome ${user.fullName}` })
    sendSuccessResponse({
        res,
        statusCode: HttpStatus.OK,
        message: `Authentication successful, Welcome ${user.name}`,
        data: user
    })

})


export const changePassword = asyncErrorHandler(async (req, res) => {

    const { email, oldPassword, newPassword } = req.body;

    const user = await User.findOne({ email });

    if (!user) {
        throwError({ statusCode: HttpStatus.NOT_FOUND, message: 'User not found' })
    }

    // Compare oldPassword with stored hashed password using bcrypt
    const passwordMatch = await bcrypt.compare(oldPassword, user.password);

    if (!passwordMatch) {
        throwError({ statusCode: HttpStatus.BAD_REQUEST, message: 'Incorrect old password.' })
    }

    user.password = newPassword;
    await user.save();

    sendSuccessResponse({
        res,
        statusCode: HttpStatus.OK,
        message: "Password is changes successfully"
    })

})

export const deleteUser = asyncErrorHandler(async (req, res) => {
    const email = req.params.email;

    if (!email) {
        throwError({ statusCode: HttpStatus.BAD_REQUEST, message: 'Email is required' });
    }

    const user = await User.findOne({ email });

    if (!user) {
        throwError({ statusCode: HttpStatus.NOT_FOUND, message: 'User not found' });
    }

    await User.deleteOne({ email });

    sendSuccessResponse({
        res,
        statusCode: HttpStatus.OK,
        message: "User deleted successfully"
    });
});

// Update User
export const updateUser = asyncErrorHandler(async (req, res) => {

    const email = req.params.email;
    const { updatedData } = req.body;

    if (!email || !updatedData) {
        throwError({ statusCode: HttpStatus.BAD_REQUEST, message: 'Email or updated data is required' });
    }

    const user = await User.findOne({ email });

    if (!user) {
        throwError({ statusCode: HttpStatus.NOT_FOUND, message: 'User not found' });
    }

    // Update user's data based on newData
    Object.assign(user, updatedData);
    const newUserData = await user.save();

    sendSuccessResponse({
        res,
        statusCode: HttpStatus.OK,
        message: "User updated successfully",
        data: {
            name: newUserData.name,
            email: newUserData.email,
            phoneNumber: newUserData.phoneNumber,
            address: newUserData.address
        }
    });
});


// Get emails of all students
export const getAllStudentEmails = async () => {
    try {
        const students = await User.find({ role: 'student' }).select('email');

        if (!students || students.length === 0) {
            throwError({ statusCode: HttpStatus.NOT_FOUND, message: 'No students found' });
        }

        const studentEmails = students.map(student => student.email);

        return studentEmails;
    } catch (error) {
        return [];
    }
};
